------

interface Props {interface Props {

  src: string;  src: string;

  alt: string;  alt: string;

  width?: number;  width?: number;

  height?: number;  height?: number;

  quality?: number;  quality?: number;

  class?: string;  class?: string;

  loading?: 'lazy' | 'eager';  loading?: 'lazy' | 'eager';

  sizes?: string;  sizes?: string;

  responsive?: boolean;  responsive?: boolean;

}}



const {const {

  src,  src,

  alt,  alt,

  width = 800,  width = 800,

  height = 600,  height = 600,

  quality = 80,  quality = 80,

  class: className = '',  class: className = '',

  loading = 'lazy',  loading = 'lazy',

  sizes = '(min-width: 1024px) 800px, (min-width: 768px) 600px, 100vw',  sizes = '(min-width: 1024px) 800px, (min-width: 768px) 600px, 100vw',

  responsive = true  responsive = true

} = Astro.props;} = Astro.props;



// Costruiamo l'URL per il servizio di conversione on-the-fly// Costruiamo l'URL per il servizio di conversione on-the-fly

const baseUrl = import.meta.env.SITE || 'https://kelua.netlify.app';const baseUrl = import.meta.env.SITE || 'https://kelua.netlify.app';

const imageUrl = src.startsWith('/') ? `${baseUrl}${src}` : src;const imageUrl = src.startsWith('/') ? `${baseUrl}${src}` : src;



// Funzione per generare URL ottimizzati usando images.weserv.nl// Funzione per generare URL ottimizzati usando images.weserv.nl

const getOptimizedUrl = (format: string, w?: number, q?: number) => {const getOptimizedUrl = (format: string, w?: number, q?: number) => {

  const params = new URLSearchParams();  const params = new URLSearchParams();

  params.set('url', imageUrl);  params.set('url', imageUrl);

  params.set('output', format);  params.set('output', format);

  if (w) params.set('w', w.toString());  if (w) params.set('w', w.toString());

  if (q) params.set('q', q.toString());  if (q) params.set('q', q.toString());

  params.set('fit', 'cover');  params.set('fit', 'cover');

  return `https://images.weserv.nl/?${params.toString()}`;  return `https://images.weserv.nl/?${params.toString()}`;

};};



// Generiamo i diversi formati usando il servizio di conversione// Logica universale per ottenere il nome ottimizzato

const webpSrc = getOptimizedUrl('webp', width, quality);const getOptimizedFilename = (originalFilename: string) => {

const avifSrc = getOptimizedUrl('avif', width, quality);  const lastDot = originalFilename.lastIndexOf('.');

  const nameWithoutExt = lastDot !== -1 ? originalFilename.substring(0, lastDot) : originalFilename;

// Fallback sicuro: sempre l'immagine originale  

const fallbackSrc = src.startsWith('/') ? src : `/${src}`;  // Sanitizzazione base

  let sanitizedName = nameWithoutExt

if (import.meta.env.DEV) {    .replace(/\s+/g, '-')           // Sostituisce spazi con trattini

  console.log('üñºÔ∏è OptimizedImage on-the-fly:', {    .replace(/[√†√°√¢√§√£√•]/g, 'a')      // Sostituisce caratteri accentati

    original: src,    .replace(/[√®√©√™√´]/g, 'e')

    webp: webpSrc,    .replace(/[√¨√≠√Æ√Ø]/g, 'i')

    avif: avifSrc,    .replace(/[√≤√≥√¥√∂√µ√∏]/g, 'o')

    fallback: fallbackSrc    .replace(/[√π√∫√ª√º]/g, 'u')

  });    .replace(/[√Ω√ø]/g, 'y')

}    .replace(/[√±]/g, 'n')

---    .replace(/[√ß]/g, 'c')

    .replace(/[^\w\-_.]/g, '');     // Rimuove caratteri non alfanumerici eccetto - _ .

<picture class={className}>  

  <!-- AVIF: formato pi√π moderno e compatto -->  // EURISTICA UNIVERSALE basata sui pattern osservati:

  <source   // Se il file ha gi√† trattini (come IMG-3624.jpeg), mantienili

    srcset={avifSrc}  // Se ha underscore e match pattern specifici, trasforma in base ai pattern esistenti:

    type="image/avif"   if (sanitizedName.includes('_')) {

    sizes={responsive ? sizes : undefined}    // Pattern osservati nel sistema di ottimizzazione:

  />    // IMG_36xx ‚Üí IMG-36xx (trasforma underscore in trattino)

      // IMG_2xxx, IMG_1xxx, file lunghi ‚Üí mantiene underscore

  <!-- WebP: ampio supporto e buona compressione -->    

  <source     if (sanitizedName.match(/^IMG_36\d+$/)) {

    srcset={webpSrc}      // Caso specifico IMG_36xx: trasforma underscore in trattino

    type="image/webp"       sanitizedName = sanitizedName.replace('_', '-');

    sizes={responsive ? sizes : undefined}    }

  />    // Per tutti gli altri pattern con underscore, mantieni l'underscore

      // Questo include IMG_2xxx, IMG_1xxx, nomi lunghi numerici, etc.

  <!-- Fallback: immagine originale -->  }

  <img  

    src={fallbackSrc}  if (import.meta.env.DEV) {

    alt={alt}    console.log(`ÔøΩ Filename optimization: "${originalFilename}" ‚Üí "${sanitizedName}"`);

    width={width}  }

    height={height}  

    loading={loading}  return sanitizedName;

    decoding="async"};

    class="optimized-image"

    sizes={responsive ? sizes : undefined}// Determina il percorso dell'immagine ottimizzata con logica universale

  />const getOptimizedImagePath = (originalSrc: string, format: string) => {

</picture>  if (!originalSrc) return '';

  

<style>  // Se l'immagine √® gi√† in uploads/, usa il percorso ottimizzato

  picture {  if (originalSrc.includes('/uploads/')) {

    width: 100%;    // Estrai il percorso completo dall'URL

    height: 100%;    const urlParts = originalSrc.split('/');

    display: block;    const filename = urlParts[urlParts.length - 1];

  }    

      if (filename) {

  .optimized-image {      // Ottieni il nome ottimizzato usando la logica universale

    width: 100%;      const optimizedName = getOptimizedFilename(filename);

    height: 100%;      

    object-fit: cover;      // Controlla se l'immagine √® in una sottocartella

    display: block;      const uploadsIndex = urlParts.findIndex(part => part === 'uploads');

    transition: opacity 0.3s ease;      if (uploadsIndex !== -1 && uploadsIndex < urlParts.length - 2) {

  }        // L'immagine √® in una sottocartella (es: /uploads/Foto_maglie/IMG_001.jpeg)

          const subfolderPath = urlParts.slice(uploadsIndex + 1, -1).join('/'); // "Foto_maglie"

  .optimized-image[loading="lazy"] {        const optimizedSubfolder = `${subfolderPath}_ottimizzate`; // "Foto_maglie_ottimizzate"

    opacity: 0;        return `/uploads/optimized/${optimizedSubfolder}/${optimizedName}.${format}`;

    animation: fadeIn 0.5s ease forwards;      } else {

  }        // L'immagine √® direttamente in uploads/ (comportamento esistente)

          return `/uploads/optimized/${optimizedName}.${format}`;

  @keyframes fadeIn {      }

    to {    }

      opacity: 1;  }

    }  

  }  return originalSrc;

</style>};

// Otteniamo i percorsi ottimizzati
const webpSrc = getOptimizedImagePath(src, 'webp');
const avifSrc = getOptimizedImagePath(src, 'avif');

// Verifica se i file ottimizzati esistono davvero
const checkFileExists = async (filePath: string) => {
  if (!filePath || filePath === src) return false;
  
  try {
    // In ambiente di build, assumiamo che esistano se sono stati generati
    if (import.meta.env.PROD) {
      // Controlla se il percorso sembra valido
      return filePath.includes('/optimized/') && filePath !== src;
    }
    
    // In sviluppo, controlla fisicamente se esistono
    const fs = await import('fs');
    const path = await import('path');
    const publicPath = path.join(process.cwd(), 'public', filePath);
    return fs.existsSync(publicPath);
  } catch {
    return false;
  }
};

// Verifica esistenza file ottimizzati
// In produzione, controlla se la cartella ottimizzata √® nella lista di quelle esistenti
const hasOptimizedFolder = (imagePath: string) => {
  if (!imagePath.includes('/optimized/')) return false;
  
  // Lista delle cartelle ottimizzate che sappiamo esistere su TinaCloud
  const existingOptimizedFolders = [
    'Foto_Jeans_ottimizzate',
    'Foto_Negozio_ottimizzate', 
    'Foto_Felpe_ottimizzate',
    'Foto_Maglieria_ottimizzate', // ‚úÖ Ora esiste su TinaCloud!
    'Foto_Giubbotti_ottimizzate', // Aggiungi quando carichi su TinaCloud
    'Foto_Accessori_ottimizzate', // Aggiungi quando carichi su TinaCloud
    'Foto_Camicie_ottimizzate',   // Aggiungi quando carichi su TinaCloud
    'Foto_Pantaloni_ottimizzate', // Aggiungi quando carichi su TinaCloud
  ];
  
  return existingOptimizedFolders.some(folder => imagePath.includes(folder));
};

const webpExists = import.meta.env.DEV 
  ? await checkFileExists(webpSrc) 
  : hasOptimizedFolder(webpSrc);
  
const avifExists = import.meta.env.DEV 
  ? await checkFileExists(avifSrc) 
  : hasOptimizedFolder(avifSrc);

// Usa solo i percorsi che esistono davvero
const finalWebpSrc = webpExists ? webpSrc : null;
const finalAvifSrc = avifExists ? avifSrc : null;

// Per sicurezza, usiamo sempre l'immagine originale come fallback principale
const safeFallbackSrc = src;

// Genera srcset responsive per diverse risoluzioni  
const generateSrcSet = (baseSrc: string, format: string) => {
  if (!responsive) return '';
  
  const sizes = [400, 600, 800, 1200];
  const optimizedBasePath = getOptimizedImagePath(baseSrc, format);
  
  return sizes.map(size => {
    // Per il responsive, usiamo lo stesso percorso ottimizzato per tutte le dimensioni
    // In futuro si potrebbe aggiungere supporto per diverse risoluzioni per file
    return `${optimizedBasePath} ${size}w`;
  }).join(', ');
};

// Debug: mostra i percorsi generati (solo in sviluppo)
if (import.meta.env.DEV) {
  console.log('üñºÔ∏è OptimizedImage Debug:');
  console.log('  Original:', src);
  console.log('  WebP:', webpSrc);
  console.log('  AVIF:', avifSrc);
  
  // Mostra se √® una sottocartella
  if (src.includes('/uploads/') && src.split('/').length > 3) {
    const pathParts = src.split('/');
    const subfolderPath = pathParts.slice(pathParts.findIndex(p => p === 'uploads') + 1, -1).join('/');
    console.log('  üìÅ Subfolder detected:', subfolderPath);
    console.log('  üìÅ Optimized folder:', `${subfolderPath}_ottimizzate`);
  }
}

---

<picture class={className}>
  <!-- Solo se il percorso ottimizzato esiste davvero, proviamo i formati moderni -->
  {finalAvifSrc && (
    <source 
      srcset={finalAvifSrc}
      type="image/avif" 
      sizes={sizes}
    />
  )}
  
  {finalWebpSrc && (
    <source 
      srcset={finalWebpSrc}
      type="image/webp" 
      sizes={sizes}
    />
  )}
  
  <!-- Fallback: sempre l'immagine originale che sappiamo esistere -->
  <img
    src={safeFallbackSrc}
    alt={alt}
    width={width}
    height={height}
    loading={loading}
    decoding="async"
    class="optimized-image"
    sizes={sizes}
  />
</picture>

<style>
  picture {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  .optimized-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    transition: opacity 0.3s ease;
  }
  
  .optimized-image[loading="lazy"] {
    opacity: 0;
    animation: fadeIn 0.5s ease forwards;
  }
  
  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }
</style>
