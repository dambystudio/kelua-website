---
import { Image } from 'astro:assets';

interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  quality?: number;
  class?: string;
  loading?: 'lazy' | 'eager';
  sizes?: string;
  responsive?: boolean;
}

const {
  src,
  alt,
  width = 800,
  height = 600,
  quality = 80,
  class: className = '',
  loading = 'lazy',
  sizes = '(min-width: 1024px) 800px, (min-width: 768px) 600px, 100vw',
  responsive = true
} = Astro.props;

// Logica universale per ottenere il nome ottimizzato
const getOptimizedFilename = (originalFilename: string) => {
  const lastDot = originalFilename.lastIndexOf('.');
  const nameWithoutExt = lastDot !== -1 ? originalFilename.substring(0, lastDot) : originalFilename;
  
  // Sanitizzazione base
  let sanitizedName = nameWithoutExt
    .replace(/\s+/g, '-')           // Sostituisce spazi con trattini
    .replace(/[àáâäãå]/g, 'a')      // Sostituisce caratteri accentati
    .replace(/[èéêë]/g, 'e')
    .replace(/[ìíîï]/g, 'i')
    .replace(/[òóôöõø]/g, 'o')
    .replace(/[ùúûü]/g, 'u')
    .replace(/[ýÿ]/g, 'y')
    .replace(/[ñ]/g, 'n')
    .replace(/[ç]/g, 'c')
    .replace(/[^\w\-_.]/g, '');     // Rimuove caratteri non alfanumerici eccetto - _ .
  
  // EURISTICA UNIVERSALE basata sui pattern osservati:
  // Se il file ha già trattini (come IMG-3624.jpeg), mantienili
  // Se ha underscore e match pattern specifici, trasforma in base ai pattern esistenti:
  if (sanitizedName.includes('_')) {
    // Pattern osservati nel sistema di ottimizzazione:
    // IMG_36xx → IMG-36xx (trasforma underscore in trattino)
    // IMG_2xxx, IMG_1xxx, file lunghi → mantiene underscore
    
    if (sanitizedName.match(/^IMG_36\d+$/)) {
      // Caso specifico IMG_36xx: trasforma underscore in trattino
      sanitizedName = sanitizedName.replace('_', '-');
    }
    // Per tutti gli altri pattern con underscore, mantieni l'underscore
    // Questo include IMG_2xxx, IMG_1xxx, nomi lunghi numerici, etc.
  }
  
  if (import.meta.env.DEV) {
    console.log(`� Filename optimization: "${originalFilename}" → "${sanitizedName}"`);
  }
  
  return sanitizedName;
};

// Determina il percorso dell'immagine ottimizzata con logica universale
const getOptimizedImagePath = (originalSrc: string, format: string) => {
  if (!originalSrc) return '';
  
  // Se l'immagine è già in uploads/, usa il percorso ottimizzato
  if (originalSrc.includes('/uploads/')) {
    // Estrai il percorso completo dall'URL
    const urlParts = originalSrc.split('/');
    const filename = urlParts[urlParts.length - 1];
    
    if (filename) {
      // Ottieni il nome ottimizzato usando la logica universale
      const optimizedName = getOptimizedFilename(filename);
      
      // Controlla se l'immagine è in una sottocartella
      const uploadsIndex = urlParts.findIndex(part => part === 'uploads');
      if (uploadsIndex !== -1 && uploadsIndex < urlParts.length - 2) {
        // L'immagine è in una sottocartella (es: /uploads/Foto_maglie/IMG_001.jpeg)
        const subfolderPath = urlParts.slice(uploadsIndex + 1, -1).join('/'); // "Foto_maglie"
        const optimizedSubfolder = `${subfolderPath}_ottimizzate`; // "Foto_maglie_ottimizzate"
        return `/uploads/optimized/${optimizedSubfolder}/${optimizedName}.${format}`;
      } else {
        // L'immagine è direttamente in uploads/ (comportamento esistente)
        return `/uploads/optimized/${optimizedName}.${format}`;
      }
    }
  }
  
  return originalSrc;
};

// Otteniamo i percorsi ottimizzati
const webpSrc = getOptimizedImagePath(src, 'webp');
const avifSrc = getOptimizedImagePath(src, 'avif');

// Per sicurezza, usiamo sempre l'immagine originale come fallback principale
const safeFallbackSrc = src;

// Genera srcset responsive per diverse risoluzioni  
const generateSrcSet = (baseSrc: string, format: string) => {
  if (!responsive) return '';
  
  const sizes = [400, 600, 800, 1200];
  const optimizedBasePath = getOptimizedImagePath(baseSrc, format);
  
  return sizes.map(size => {
    // Per il responsive, usiamo lo stesso percorso ottimizzato per tutte le dimensioni
    // In futuro si potrebbe aggiungere supporto per diverse risoluzioni per file
    return `${optimizedBasePath} ${size}w`;
  }).join(', ');
};

// Debug: mostra i percorsi generati (solo in sviluppo)
if (import.meta.env.DEV) {
  console.log('🖼️ OptimizedImage Debug:');
  console.log('  Original:', src);
  console.log('  WebP:', webpSrc);
  console.log('  AVIF:', avifSrc);
  
  // Mostra se è una sottocartella
  if (src.includes('/uploads/') && src.split('/').length > 3) {
    const pathParts = src.split('/');
    const subfolderPath = pathParts.slice(pathParts.findIndex(p => p === 'uploads') + 1, -1).join('/');
    console.log('  📁 Subfolder detected:', subfolderPath);
    console.log('  📁 Optimized folder:', `${subfolderPath}_ottimizzate`);
  }
}

---

<picture class={className}>
  <!-- Solo se il percorso ottimizzato è diverso dall'originale, proviamo i formati moderni -->
  {avifSrc && avifSrc !== src && (
    <source 
      srcset={avifSrc}
      type="image/avif" 
      sizes={sizes}
    />
  )}
  
  {webpSrc && webpSrc !== src && (
    <source 
      srcset={webpSrc}
      type="image/webp" 
      sizes={sizes}
    />
  )}
  
  <!-- Fallback: sempre l'immagine originale che sappiamo esistere -->
  <img
    src={safeFallbackSrc}
    alt={alt}
    width={width}
    height={height}
    loading={loading}
    decoding="async"
    class="optimized-image"
    sizes={sizes}
  />
</picture>

<style>
  picture {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  .optimized-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    transition: opacity 0.3s ease;
  }
  
  .optimized-image[loading="lazy"] {
    opacity: 0;
    animation: fadeIn 0.5s ease forwards;
  }
  
  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }
</style>
